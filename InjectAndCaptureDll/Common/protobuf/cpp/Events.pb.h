// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Events.proto

#ifndef PROTOBUF_INCLUDED_Events_2eproto
#define PROTOBUF_INCLUDED_Events_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Events_2eproto 

namespace protobuf_Events_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Events_2eproto
class InputEvent;
class InputEventDefaultTypeInternal;
extern InputEventDefaultTypeInternal _InputEvent_default_instance_;
class InputEventList;
class InputEventListDefaultTypeInternal;
extern InputEventListDefaultTypeInternal _InputEventList_default_instance_;
class InputEvent_KeyboardEventType;
class InputEvent_KeyboardEventTypeDefaultTypeInternal;
extern InputEvent_KeyboardEventTypeDefaultTypeInternal _InputEvent_KeyboardEventType_default_instance_;
class InputEvent_MouseEventType;
class InputEvent_MouseEventTypeDefaultTypeInternal;
extern InputEvent_MouseEventTypeDefaultTypeInternal _InputEvent_MouseEventType_default_instance_;
namespace google {
namespace protobuf {
template<> ::InputEvent* Arena::CreateMaybeMessage<::InputEvent>(Arena*);
template<> ::InputEventList* Arena::CreateMaybeMessage<::InputEventList>(Arena*);
template<> ::InputEvent_KeyboardEventType* Arena::CreateMaybeMessage<::InputEvent_KeyboardEventType>(Arena*);
template<> ::InputEvent_MouseEventType* Arena::CreateMaybeMessage<::InputEvent_MouseEventType>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class InputEvent_KeyboardEventType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputEvent.KeyboardEventType) */ {
 public:
  InputEvent_KeyboardEventType();
  virtual ~InputEvent_KeyboardEventType();

  InputEvent_KeyboardEventType(const InputEvent_KeyboardEventType& from);

  inline InputEvent_KeyboardEventType& operator=(const InputEvent_KeyboardEventType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputEvent_KeyboardEventType(InputEvent_KeyboardEventType&& from) noexcept
    : InputEvent_KeyboardEventType() {
    *this = ::std::move(from);
  }

  inline InputEvent_KeyboardEventType& operator=(InputEvent_KeyboardEventType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputEvent_KeyboardEventType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputEvent_KeyboardEventType* internal_default_instance() {
    return reinterpret_cast<const InputEvent_KeyboardEventType*>(
               &_InputEvent_KeyboardEventType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InputEvent_KeyboardEventType* other);
  friend void swap(InputEvent_KeyboardEventType& a, InputEvent_KeyboardEventType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputEvent_KeyboardEventType* New() const final {
    return CreateMaybeMessage<InputEvent_KeyboardEventType>(NULL);
  }

  InputEvent_KeyboardEventType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InputEvent_KeyboardEventType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InputEvent_KeyboardEventType& from);
  void MergeFrom(const InputEvent_KeyboardEventType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputEvent_KeyboardEventType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 virtualKeyCode = 1;
  void clear_virtualkeycode();
  static const int kVirtualKeyCodeFieldNumber = 1;
  ::google::protobuf::uint32 virtualkeycode() const;
  void set_virtualkeycode(::google::protobuf::uint32 value);

  // bool keyUp = 2;
  void clear_keyup();
  static const int kKeyUpFieldNumber = 2;
  bool keyup() const;
  void set_keyup(bool value);

  // @@protoc_insertion_point(class_scope:InputEvent.KeyboardEventType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 virtualkeycode_;
  bool keyup_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Events_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InputEvent_MouseEventType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputEvent.MouseEventType) */ {
 public:
  InputEvent_MouseEventType();
  virtual ~InputEvent_MouseEventType();

  InputEvent_MouseEventType(const InputEvent_MouseEventType& from);

  inline InputEvent_MouseEventType& operator=(const InputEvent_MouseEventType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputEvent_MouseEventType(InputEvent_MouseEventType&& from) noexcept
    : InputEvent_MouseEventType() {
    *this = ::std::move(from);
  }

  inline InputEvent_MouseEventType& operator=(InputEvent_MouseEventType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputEvent_MouseEventType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputEvent_MouseEventType* internal_default_instance() {
    return reinterpret_cast<const InputEvent_MouseEventType*>(
               &_InputEvent_MouseEventType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(InputEvent_MouseEventType* other);
  friend void swap(InputEvent_MouseEventType& a, InputEvent_MouseEventType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputEvent_MouseEventType* New() const final {
    return CreateMaybeMessage<InputEvent_MouseEventType>(NULL);
  }

  InputEvent_MouseEventType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InputEvent_MouseEventType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InputEvent_MouseEventType& from);
  void MergeFrom(const InputEvent_MouseEventType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputEvent_MouseEventType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // uint32 actionType = 3;
  void clear_actiontype();
  static const int kActionTypeFieldNumber = 3;
  ::google::protobuf::uint32 actiontype() const;
  void set_actiontype(::google::protobuf::uint32 value);

  // uint32 wheelRotation = 4;
  void clear_wheelrotation();
  static const int kWheelRotationFieldNumber = 4;
  ::google::protobuf::uint32 wheelrotation() const;
  void set_wheelrotation(::google::protobuf::uint32 value);

  // bool relativePosition = 5;
  void clear_relativeposition();
  static const int kRelativePositionFieldNumber = 5;
  bool relativeposition() const;
  void set_relativeposition(bool value);

  // bool mappedToVirtualDesktop = 6;
  void clear_mappedtovirtualdesktop();
  static const int kMappedToVirtualDesktopFieldNumber = 6;
  bool mappedtovirtualdesktop() const;
  void set_mappedtovirtualdesktop(bool value);

  // @@protoc_insertion_point(class_scope:InputEvent.MouseEventType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::uint32 actiontype_;
  ::google::protobuf::uint32 wheelrotation_;
  bool relativeposition_;
  bool mappedtovirtualdesktop_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Events_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InputEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputEvent) */ {
 public:
  InputEvent();
  virtual ~InputEvent();

  InputEvent(const InputEvent& from);

  inline InputEvent& operator=(const InputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputEvent(InputEvent&& from) noexcept
    : InputEvent() {
    *this = ::std::move(from);
  }

  inline InputEvent& operator=(InputEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputEvent& default_instance();

  enum EventCase {
    kKeyboardEvent = 2,
    kMouseEvent = 3,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputEvent* internal_default_instance() {
    return reinterpret_cast<const InputEvent*>(
               &_InputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(InputEvent* other);
  friend void swap(InputEvent& a, InputEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputEvent* New() const final {
    return CreateMaybeMessage<InputEvent>(NULL);
  }

  InputEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InputEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InputEvent& from);
  void MergeFrom(const InputEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InputEvent_KeyboardEventType KeyboardEventType;
  typedef InputEvent_MouseEventType MouseEventType;

  // accessors -------------------------------------------------------

  // uint64 timeSinceStartOfRecording = 1;
  void clear_timesincestartofrecording();
  static const int kTimeSinceStartOfRecordingFieldNumber = 1;
  ::google::protobuf::uint64 timesincestartofrecording() const;
  void set_timesincestartofrecording(::google::protobuf::uint64 value);

  // .InputEvent.KeyboardEventType keyboardEvent = 2;
  bool has_keyboardevent() const;
  void clear_keyboardevent();
  static const int kKeyboardEventFieldNumber = 2;
  private:
  const ::InputEvent_KeyboardEventType& _internal_keyboardevent() const;
  public:
  const ::InputEvent_KeyboardEventType& keyboardevent() const;
  ::InputEvent_KeyboardEventType* release_keyboardevent();
  ::InputEvent_KeyboardEventType* mutable_keyboardevent();
  void set_allocated_keyboardevent(::InputEvent_KeyboardEventType* keyboardevent);

  // .InputEvent.MouseEventType mouseEvent = 3;
  bool has_mouseevent() const;
  void clear_mouseevent();
  static const int kMouseEventFieldNumber = 3;
  private:
  const ::InputEvent_MouseEventType& _internal_mouseevent() const;
  public:
  const ::InputEvent_MouseEventType& mouseevent() const;
  ::InputEvent_MouseEventType* release_mouseevent();
  ::InputEvent_MouseEventType* mutable_mouseevent();
  void set_allocated_mouseevent(::InputEvent_MouseEventType* mouseevent);

  void clear_Event();
  EventCase Event_case() const;
  // @@protoc_insertion_point(class_scope:InputEvent)
 private:
  void set_has_keyboardevent();
  void set_has_mouseevent();

  inline bool has_Event() const;
  inline void clear_has_Event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 timesincestartofrecording_;
  union EventUnion {
    EventUnion() {}
    ::InputEvent_KeyboardEventType* keyboardevent_;
    ::InputEvent_MouseEventType* mouseevent_;
  } Event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Events_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InputEventList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InputEventList) */ {
 public:
  InputEventList();
  virtual ~InputEventList();

  InputEventList(const InputEventList& from);

  inline InputEventList& operator=(const InputEventList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputEventList(InputEventList&& from) noexcept
    : InputEventList() {
    *this = ::std::move(from);
  }

  inline InputEventList& operator=(InputEventList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InputEventList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputEventList* internal_default_instance() {
    return reinterpret_cast<const InputEventList*>(
               &_InputEventList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(InputEventList* other);
  friend void swap(InputEventList& a, InputEventList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputEventList* New() const final {
    return CreateMaybeMessage<InputEventList>(NULL);
  }

  InputEventList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InputEventList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InputEventList& from);
  void MergeFrom(const InputEventList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputEventList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .InputEvent inputEvents = 1;
  int inputevents_size() const;
  void clear_inputevents();
  static const int kInputEventsFieldNumber = 1;
  ::InputEvent* mutable_inputevents(int index);
  ::google::protobuf::RepeatedPtrField< ::InputEvent >*
      mutable_inputevents();
  const ::InputEvent& inputevents(int index) const;
  ::InputEvent* add_inputevents();
  const ::google::protobuf::RepeatedPtrField< ::InputEvent >&
      inputevents() const;

  // @@protoc_insertion_point(class_scope:InputEventList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::InputEvent > inputevents_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Events_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InputEvent_KeyboardEventType

// uint32 virtualKeyCode = 1;
inline void InputEvent_KeyboardEventType::clear_virtualkeycode() {
  virtualkeycode_ = 0u;
}
inline ::google::protobuf::uint32 InputEvent_KeyboardEventType::virtualkeycode() const {
  // @@protoc_insertion_point(field_get:InputEvent.KeyboardEventType.virtualKeyCode)
  return virtualkeycode_;
}
inline void InputEvent_KeyboardEventType::set_virtualkeycode(::google::protobuf::uint32 value) {
  
  virtualkeycode_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.KeyboardEventType.virtualKeyCode)
}

// bool keyUp = 2;
inline void InputEvent_KeyboardEventType::clear_keyup() {
  keyup_ = false;
}
inline bool InputEvent_KeyboardEventType::keyup() const {
  // @@protoc_insertion_point(field_get:InputEvent.KeyboardEventType.keyUp)
  return keyup_;
}
inline void InputEvent_KeyboardEventType::set_keyup(bool value) {
  
  keyup_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.KeyboardEventType.keyUp)
}

// -------------------------------------------------------------------

// InputEvent_MouseEventType

// int32 x = 1;
inline void InputEvent_MouseEventType::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 InputEvent_MouseEventType::x() const {
  // @@protoc_insertion_point(field_get:InputEvent.MouseEventType.x)
  return x_;
}
inline void InputEvent_MouseEventType::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.MouseEventType.x)
}

// int32 y = 2;
inline void InputEvent_MouseEventType::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 InputEvent_MouseEventType::y() const {
  // @@protoc_insertion_point(field_get:InputEvent.MouseEventType.y)
  return y_;
}
inline void InputEvent_MouseEventType::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.MouseEventType.y)
}

// uint32 actionType = 3;
inline void InputEvent_MouseEventType::clear_actiontype() {
  actiontype_ = 0u;
}
inline ::google::protobuf::uint32 InputEvent_MouseEventType::actiontype() const {
  // @@protoc_insertion_point(field_get:InputEvent.MouseEventType.actionType)
  return actiontype_;
}
inline void InputEvent_MouseEventType::set_actiontype(::google::protobuf::uint32 value) {
  
  actiontype_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.MouseEventType.actionType)
}

// uint32 wheelRotation = 4;
inline void InputEvent_MouseEventType::clear_wheelrotation() {
  wheelrotation_ = 0u;
}
inline ::google::protobuf::uint32 InputEvent_MouseEventType::wheelrotation() const {
  // @@protoc_insertion_point(field_get:InputEvent.MouseEventType.wheelRotation)
  return wheelrotation_;
}
inline void InputEvent_MouseEventType::set_wheelrotation(::google::protobuf::uint32 value) {
  
  wheelrotation_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.MouseEventType.wheelRotation)
}

// bool relativePosition = 5;
inline void InputEvent_MouseEventType::clear_relativeposition() {
  relativeposition_ = false;
}
inline bool InputEvent_MouseEventType::relativeposition() const {
  // @@protoc_insertion_point(field_get:InputEvent.MouseEventType.relativePosition)
  return relativeposition_;
}
inline void InputEvent_MouseEventType::set_relativeposition(bool value) {
  
  relativeposition_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.MouseEventType.relativePosition)
}

// bool mappedToVirtualDesktop = 6;
inline void InputEvent_MouseEventType::clear_mappedtovirtualdesktop() {
  mappedtovirtualdesktop_ = false;
}
inline bool InputEvent_MouseEventType::mappedtovirtualdesktop() const {
  // @@protoc_insertion_point(field_get:InputEvent.MouseEventType.mappedToVirtualDesktop)
  return mappedtovirtualdesktop_;
}
inline void InputEvent_MouseEventType::set_mappedtovirtualdesktop(bool value) {
  
  mappedtovirtualdesktop_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.MouseEventType.mappedToVirtualDesktop)
}

// -------------------------------------------------------------------

// InputEvent

// uint64 timeSinceStartOfRecording = 1;
inline void InputEvent::clear_timesincestartofrecording() {
  timesincestartofrecording_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InputEvent::timesincestartofrecording() const {
  // @@protoc_insertion_point(field_get:InputEvent.timeSinceStartOfRecording)
  return timesincestartofrecording_;
}
inline void InputEvent::set_timesincestartofrecording(::google::protobuf::uint64 value) {
  
  timesincestartofrecording_ = value;
  // @@protoc_insertion_point(field_set:InputEvent.timeSinceStartOfRecording)
}

// .InputEvent.KeyboardEventType keyboardEvent = 2;
inline bool InputEvent::has_keyboardevent() const {
  return Event_case() == kKeyboardEvent;
}
inline void InputEvent::set_has_keyboardevent() {
  _oneof_case_[0] = kKeyboardEvent;
}
inline void InputEvent::clear_keyboardevent() {
  if (has_keyboardevent()) {
    delete Event_.keyboardevent_;
    clear_has_Event();
  }
}
inline const ::InputEvent_KeyboardEventType& InputEvent::_internal_keyboardevent() const {
  return *Event_.keyboardevent_;
}
inline ::InputEvent_KeyboardEventType* InputEvent::release_keyboardevent() {
  // @@protoc_insertion_point(field_release:InputEvent.keyboardEvent)
  if (has_keyboardevent()) {
    clear_has_Event();
      ::InputEvent_KeyboardEventType* temp = Event_.keyboardevent_;
    Event_.keyboardevent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::InputEvent_KeyboardEventType& InputEvent::keyboardevent() const {
  // @@protoc_insertion_point(field_get:InputEvent.keyboardEvent)
  return has_keyboardevent()
      ? *Event_.keyboardevent_
      : *reinterpret_cast< ::InputEvent_KeyboardEventType*>(&::_InputEvent_KeyboardEventType_default_instance_);
}
inline ::InputEvent_KeyboardEventType* InputEvent::mutable_keyboardevent() {
  if (!has_keyboardevent()) {
    clear_Event();
    set_has_keyboardevent();
    Event_.keyboardevent_ = CreateMaybeMessage< ::InputEvent_KeyboardEventType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:InputEvent.keyboardEvent)
  return Event_.keyboardevent_;
}

// .InputEvent.MouseEventType mouseEvent = 3;
inline bool InputEvent::has_mouseevent() const {
  return Event_case() == kMouseEvent;
}
inline void InputEvent::set_has_mouseevent() {
  _oneof_case_[0] = kMouseEvent;
}
inline void InputEvent::clear_mouseevent() {
  if (has_mouseevent()) {
    delete Event_.mouseevent_;
    clear_has_Event();
  }
}
inline const ::InputEvent_MouseEventType& InputEvent::_internal_mouseevent() const {
  return *Event_.mouseevent_;
}
inline ::InputEvent_MouseEventType* InputEvent::release_mouseevent() {
  // @@protoc_insertion_point(field_release:InputEvent.mouseEvent)
  if (has_mouseevent()) {
    clear_has_Event();
      ::InputEvent_MouseEventType* temp = Event_.mouseevent_;
    Event_.mouseevent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::InputEvent_MouseEventType& InputEvent::mouseevent() const {
  // @@protoc_insertion_point(field_get:InputEvent.mouseEvent)
  return has_mouseevent()
      ? *Event_.mouseevent_
      : *reinterpret_cast< ::InputEvent_MouseEventType*>(&::_InputEvent_MouseEventType_default_instance_);
}
inline ::InputEvent_MouseEventType* InputEvent::mutable_mouseevent() {
  if (!has_mouseevent()) {
    clear_Event();
    set_has_mouseevent();
    Event_.mouseevent_ = CreateMaybeMessage< ::InputEvent_MouseEventType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:InputEvent.mouseEvent)
  return Event_.mouseevent_;
}

inline bool InputEvent::has_Event() const {
  return Event_case() != EVENT_NOT_SET;
}
inline void InputEvent::clear_has_Event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline InputEvent::EventCase InputEvent::Event_case() const {
  return InputEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InputEventList

// repeated .InputEvent inputEvents = 1;
inline int InputEventList::inputevents_size() const {
  return inputevents_.size();
}
inline void InputEventList::clear_inputevents() {
  inputevents_.Clear();
}
inline ::InputEvent* InputEventList::mutable_inputevents(int index) {
  // @@protoc_insertion_point(field_mutable:InputEventList.inputEvents)
  return inputevents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::InputEvent >*
InputEventList::mutable_inputevents() {
  // @@protoc_insertion_point(field_mutable_list:InputEventList.inputEvents)
  return &inputevents_;
}
inline const ::InputEvent& InputEventList::inputevents(int index) const {
  // @@protoc_insertion_point(field_get:InputEventList.inputEvents)
  return inputevents_.Get(index);
}
inline ::InputEvent* InputEventList::add_inputevents() {
  // @@protoc_insertion_point(field_add:InputEventList.inputEvents)
  return inputevents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::InputEvent >&
InputEventList::inputevents() const {
  // @@protoc_insertion_point(field_list:InputEventList.inputEvents)
  return inputevents_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Events_2eproto
